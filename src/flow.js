// Flow control components for lab.js
import { shuffle, mean } from 'lodash'
import { Component, status, handMeDowns } from './core'
import { multiArgumentConstructor } from './util/deprecation'

// Helper function to handle nested components
const prepareNested = function(nested, parent) {
  // Setup parent links on nested components
  nested.forEach(c => (c.parent = parent))

  // Set ids on nested components
  nested.forEach((c, i) => {
    // For each child, use this component's id
    // and append a counter
    if (parent.id == null) {
      c.id = String(i)
    } else {
      c.id = [parent.id, i].join('_')
    }
  })

  // Pass on specified attributes
  nested.forEach(c => {
    parent.handMeDowns.forEach(k => {
      c[k] = c[k] || parent[k]
    })
  })

  // Trigger prepare on all nested components
  return Promise.all(
    nested.map(c => c.prepare(false)) // indicate automated call
  )
}

// A sequence combines an array of other
// components and runs them sequentially
export class Sequence extends Component {
  constructor(options={}) {
    // Deprecate multiple arguments in constructor
    options = multiArgumentConstructor(
      options, arguments, ['content'], 'Sequence'
    )

    super(options)

    // Define an array of nested components
    // to iterate over
    this.content = options.content || []

    // Shuffle items, if so desired
    this.shuffle = options.shuffle || false

    // Use default hand-me-downs
    // unless directed otherwise
    // (note that the hand-me-downs are copied)
    this.handMeDowns = options.handMeDowns || [...handMeDowns]

    // Set default values for current component and index
    this.currentComponent = null
    this.currentPosition = null
  }

  async onPrepare() {
    // Shuffle content, if requested
    if (this.shuffle) {
      this.content = shuffle(this.content)
    }

    // Define an iterator over the content
    this.iterator = this.content.entries()
    this.stepper = this.step.bind(this)

    // Prepare nested items
    await prepareNested(this.content, this)
  }

  async onRun() {
    // Make the first step
    return await this.step()
  }

  onEnd() {
    // End prematurely, if necessary
    if (this.currentComponent.status !== status.done) {
      this.currentComponent.off('after:end', this.stepper)
      this.currentComponent.end('abort by sequence')
    }
  }

  async step() {
    if (this.status === status.done) {
      throw 'Sequence ended, can\'t take any more steps'
    }

    // Move through the content
    const next = this.iterator.next()
    if (next.done) {
      return await this.end()
    } else {
      [this.currentPosition, this.currentComponent] = next.value
      this.currentComponent.on('after:end', this.stepper)
      this.triggerMethod('step')
      return await this.currentComponent.run()
    }
  }

  get progress() {
    return mean(
      this.content.map(c => c.progress)
    )
  }
}

Sequence.module = ['flow']

// A loop functions exactly like a sequence,
// except that the components in the loop are
// generated upon initialization from a
// factory function and a data collection.
// Technically, the content is generated by
// mapping the data onto the factory function.
export class Loop extends Sequence {
  constructor(options={}) {
    // Deprecate multiple arguments in constructor
    options = multiArgumentConstructor(
      options, arguments, ['componentFactory', 'data'], 'Loop'
    )

    // Generate the content by applying
    // the componentFactory function to each
    // entry in the data array
    options.content = options.data.map(options.componentFactory)

    // Otherwise, behave exactly
    // as a sequence would
    super(options)
  }
}

Loop.module = ['flow']

// A parallel component executes multiple
// other components simultaneously
export class Parallel extends Component {
  constructor(options={}) {
    // Deprecate multiple arguments in constructor
    options = multiArgumentConstructor(
      options, arguments, ['content'], 'Parallel'
    )

    super(options)

    // The content, in this case,
    // consists of an array of components
    // that are run in parallel.
    this.content = options.content

    // Save options
    this.mode = options.mode || 'race'
    this.handMeDowns = options.handMeDowns || [...handMeDowns]
  }

  prepare(directCall) {
    const p = super.prepare(directCall)

    // Prepare nested items
    return p.then(
      () => prepareNested(this.content, this)
    )
  }

  // The run method is overwritten at this point,
  // because the original promise is swapped for a
  // version that runs all nested items in parallel
  onRun() {
    // End this component when all nested components,
    // or a single component, have ended
    Promise[this.mode](
      this.content.map(c => c.waitFor('end'))
    ).then(() => this.end())

    // Run all nested components simultaneously
    return Promise.all(
      this.content.map(c => c.run())
    )
  }

  onEnd() {
    // Cancel remaining running nested components
    this.content.forEach(c => {
      if (c.status < status.done) {
        c.end('abort by parallel')
      }
    })
  }

  get progress() {
    return mean(
      this.content.map(c => c.progress)
    )
  }
}

Parallel.module = ['flow']
