import { cloneDeep, isFunction } from 'lodash'
import { Component } from '../core/component'
import { clone } from '../base/util/clone'

import { Sequence, SequenceOptions } from './sequence'
import { sampleMode } from './util/sample'

const loopDefaults = {
  template: <
    | Component
    | Component[]
    | ((parameters: object, index: number, parent: Component) => Component)
    | undefined
  >undefined,
  templateParameters: <Record<string, any>[]>[],
  sample: {
    n: <number | undefined>undefined,
    mode: <'sequential' | 'draw' | 'draw-shuffle' | 'draw-replace'>'sequential',
  },
  shuffleGroups: <string[][] | undefined>undefined,
  shuffleUngrouped: false,
}

export type LoopOptions = SequenceOptions & typeof loopDefaults

// A loop functions exactly like a sequence,
// except that the components in the loop are
// generated upon initialization from a
// factory function and a data collection.
// Technically, the content is generated by
// mapping the data onto the factory function.
export class Loop extends Sequence {
  options!: LoopOptions

  constructor(options: Partial<LoopOptions> = {}) {
    super({
      ...cloneDeep(loopDefaults),
      ...options,
    })
  }

  onPrepare() {
    let templateParameters: Record<string, any>[] = []
    if (
      Array.isArray(this.options.templateParameters) &&
      this.options.templateParameters.length > 0
    ) {
      // Shuffle columns independently, if requested
      const shuffleTable =
        Array.isArray(this.options.shuffleGroups) &&
        this.options.shuffleGroups.length

      const shuffledParameters = shuffleTable
        ? this.random.shuffleTable(
            this.options.templateParameters,
            this.options.shuffleGroups,
            this.options.shuffleUngrouped,
          )
        : this.options.templateParameters

      // Sample parameters
      templateParameters = sampleMode(
        this.random,
        shuffledParameters,
        this.options.sample.n,
        this.options.sample.mode,
      )
    } else {
      console.warn(
        'Empty or invalid parameter set for loop, no content generated',
      )
    }

    // Generate the content by cloning the template,
    // replacing the parameters each time, or by
    // mapping the parameters onto a function that
    // returns a component.
    const template = this.options.template
    if (template instanceof Component) {
      this.options.content = templateParameters.map(p => {
        const c = clone(template)
        // Extend parameters
        c.options.parameters = {
          ...c.options.parameters,
          ...p,
        }
        return c
      })
    } else if (Array.isArray(template)) {
      this.options.content = templateParameters.flatMap(p =>
        template.map((t: Component) => {
          const c = clone(t)
          c.options.parameters = {
            ...t.options.parameters,
            ...p,
          }
          return c
        }),
      )
    } else if (isFunction(template)) {
      this.options.content = templateParameters.map((p, i) =>
        template(p, i, this),
      )
    } else {
      console.warn('Missing or invalid template in loop, no content generated')
    }

    return super.onPrepare()
  }
}

Loop.metadata = {
  module: ['flow'],
  nestedComponents: ['template'],
  parsableOptions: {
    templateParameters: {
      type: 'array',
      content: {
        // Parse the values of objects in
        // the templateParameters array
        content: {
          '*': {},
        },
      },
    },
    sample: {
      type: 'object',
      content: {
        n: { type: 'number' },
        replace: { type: 'boolean' },
        mode: {},
      },
    },
  },
}
